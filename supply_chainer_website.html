<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Supply Chainer | Firma Digitale, DDT e Fatture in Tasca</title>
    <meta name="description" content="L'app mobile per aziende che vogliono firmare digitalmente, gestire DDT e fatture ovunque si trovino. VelocitÃ , sicurezza e zero carta.">
    <link rel="icon" type="image/png" href="SUPPLY.png">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <style>
        :root {
            --black: #0F0F0F;
            --darkblue: #1A1F2E;
            --orange: #FFB400;
            --gray-light: #F5F5F5;
            --gray-dark: #222222;
        }
        * { margin:0; padding:0; box-sizing:border-box; }
        body {
            font-family: 'Inter', sans-serif;
            background: var(--black);
            color: white;
            line-height: 1.6;
        }
        .container { max-width: 1280px; margin: 0 auto; padding: 0 20px; }

        /* Header */
        header {
            background: linear-gradient(135deg, var(--darkblue) 0%, var(--black) 100%);
            padding: 20px 0;
            position: fixed;
            width: 100%;
            top: 0;
            z-index: 1000;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }
        .header-inner {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .logo {
            display: flex;
            align-items: center;
            font-size: 32px;
            font-weight: 800;
        }
        .logo span {
            color: var(--orange);
        }
        .logo-img {
            height: 60px;
            margin-right: 12px;
        }
        .cta-header {
            background: var(--orange);
            color: var(--black);
            padding: 12px 32px;
            border-radius: 50px;
            font-weight: 700;
            text-decoration: none;
            transition: all 0.3s;
        }
        .cta-header:hover { transform: scale(1.05); }

        /* Hero */
        .hero {
            position: relative;
            overflow: hidden;
            padding: 180px 0 120px;
            text-align: center;
        }
        .hero h1 {
            font-size: 4.5rem;
            font-weight: 800;
            margin-bottom: 24px;
            line-height: 1.1;
        }
        .hero h1 span {
            color: var(--orange);
        }
        .hero p {
            font-size: 1.5rem;
            max-width: 800px;
            margin: 0 auto 40px;
            opacity: 0.9;
        }
        .hero-img {
            max-width: 100%;
            margin: 60px auto;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(255,180,0,0.2);
        }
        .hero-anim {
            position: relative;
            height: 500px;
            margin: 60px auto;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(255,180,0,0.2);
            overflow: hidden;
        }
        .hero-anim .webgl {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        .hero-anim-text {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: clamp(24px, 4vw, 48px);
            font-weight: 800;
            color: white;
            text-shadow: 0 6px 20px rgba(0,0,0,0.4);
            z-index: 2;
            pointer-events: none;
            letter-spacing: 0.5px;
            will-change: transform, opacity;
        }
        .hero-anim-text span { color: var(--orange); }

        .progress-bar {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: rgba(255,255,255,0.08);
            z-index: 1200;
        }
        .progress-bar__inner {
            width: 100%;
            height: 100%;
            background: var(--orange);
            transform-origin: left center;
            transform: scaleX(0);
            will-change: transform;
        }
        .cta-hero {
            background: var(--orange);
            color: var(--black);
            font-size: 1.4rem;
            font-weight: 700;
            padding: 20px 50px;
            border-radius: 60px;
            text-decoration: none;
            display: inline-block;
            margin: 0 15px;
            transition: all 0.3s;
        }
        .cta-hero:hover { transform: translateY(-5px); box-shadow: 0 20px 40px rgba(255,180,0,0.3); }
        .cta-secondary {
            background: transparent;
            color: white;
            border: 2px solid var(--orange);
        }

        /* Features */
        .features {
            padding: 120px 0;
            background: var(--gray-dark);
        }
        .section-title {
            text-align: center;
            font-size: 3rem;
            margin-bottom: 80px;
        }
        .section-title span.word { color: var(--orange); display: inline-block; opacity: 0; transform: translateY(20px); }
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 40px;
        }
        .feature-card {
            background: rgba(255,180,0,0.05);
            padding: 40px;
            border-radius: 20px;
            border: 1px solid rgba(255,180,0,0.2);
            text-align: center;
        }
        .feature-icon {
            font-size: 4rem;
            margin-bottom: 20px;
        }
        .feature-card h3 {
            font-size: 1.8rem;
            margin-bottom: 16px;
        }

        /* Benefits */
        .benefits {
            padding: 120px 0;
            background: var(--black);
        }
        .benefit {
            display: flex;
            align-items: center;
            margin-bottom: 80px;
        }
        .benefit:nth-child(even) {
            flex-direction: row-reverse;
        }
        .benefit-text {
            flex: 1;
            padding: 0 40px;
        }
        .benefit-text h3 {
            font-size: 2.5rem;
            margin-bottom: 20px;
        }
        .benefit-text h3 span { color: var(--orange); }
        .benefit-img {
            flex: 1;
            text-align: center;
        }
        .benefit-img img {
            max-width: 90%;
            border-radius: 20px;
        }

        /* CTA Final */
        .cta-final {
            padding: 140px 0;
            text-align: center;
            background: linear-gradient(135deg, var(--orange) 0%, #ff8c00 100%);
            color: var(--black);
        }
        .cta-final h2 {
            font-size: 4rem;
            margin-bottom: 30px;
        }
        .cta-final .cta-hero {
            background: var(--black);
            color: white;
            font-size: 1.6rem;
        }

        /* Footer */
        footer {
            background: var(--darkblue);
            padding: 80px 0 40px;
            text-align: center;
        }
        footer .logo { justify-content: center; margin-bottom: 20px; }
        footer p { opacity: 0.7; }

        /* Video Modal */
        .video-modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.8);
        }
        .video-modal-content {
            position: relative;
            margin: 5% auto;
            padding: 20px;
            width: 80%;
            max-width: 900px;
        }
        .close-modal {
            color: #fff;
            position: absolute;
            top: -20px;
            right: 0;
            font-size: 40px;
            font-weight: bold;
            cursor: pointer;
        }

        @media (max-width: 768px) {
            .hero h1 { font-size: 3rem; }
            .hero p { font-size: 1.2rem; }
            .benefit { flex-direction: column !important; }
            .benefit-text { text-align: center; padding: 20px 0; }
            .hero-anim { height: 320px; margin: 40px auto; }
            .hero-anim-text { font-size: clamp(20px, 5vw, 32px); top: 16px; }
            header { padding: 14px 0; }
            .section-title { font-size: 2.2rem; }
            .section-title span.word { font-size: 2.2rem; }
        }
    </style>
</head>
<body>

    <header>
        <div class="container header-inner">
            <div class="logo">
                <img src="SUPPLY.png" alt="Supply Chainer" class="logo-img">
                Supply<span>Chainer</span>
            </div>
            <div><a href="index.html" class="cta-header">Torna alla Home</a><a href="#download" class="cta-header" style="margin-left: 15px;">Provalo Gratis</a></div>
        </div>
    </header>

    <div class="progress-bar"><div class="progress-bar__inner"></div></div>

    <section class="hero">
        <video autoplay loop muted playsinline style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; z-index: 0;">
            <source src="video/prova1.mp4" type="video/mp4">
        </video>
        <div style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(26, 31, 46, 0.7); z-index: 1;"></div>
        <div class="container" style="position: relative; z-index: 2;">
            <img src="SUPPLY.png" alt="Supply Chainer" class="logo-img">
            <h1>La tua <span>Supply Chain</span><br>non Ã¨ mai stata cosÃ¬ veloce</h1>
            <p>Firma digitalmente DDT e fatture direttamente dal tuo tablet o smartphone.<br>Niente piÃ¹ stampe, scanner o ritardi. Tutto in pochi tap.</p>
            
            <div>
                <a href="#download" class="cta-hero">Scarica Ora Gratis</a>
                <a href="#demo" class="cta-hero cta-secondary">Guarda il Video</a>
            </div>
        </div>
    </section>

    <section class="features">
        <div class="container">
            <h2 class="section-title">
                <span class="word">PerchÃ©</span>
                <span class="word">le</span>
                <span class="word">aziende</span>
                <span class="word">scelgono</span>
                <span class="word">Supply</span>
                <span class="word">Chainer</span>
            </h2>
            
            <div class="grid">
                <div class="feature-card">
                    <div class="feature-icon">âœ¨</div>
                    <h3>Firma Digitale Legale</h3>
                    <p>Firma grafometrica o con certificato digitale qualificata. Valore legale al 100% in tutta l'UE.</p>
                </div>
                <div class="feature-card">
                    <div class="feature-icon">ðŸšš</div>
                    <h3>DDT in Tempo Reale</h3>
                    <p>Il conducente firma sul tablet, il cliente riceve il DDT firmato via email in 3 secondi.</p>
                </div>
                <div class="feature-card">
                    <div class="feature-icon">ðŸ“„</div>
                    <h3>Fatturazione Immediata</h3>
                    <p>Trasforma automaticamente i DDT firmati in fatture elettroniche verso SdI.</p>
                </div>
                <div class="feature-card">
                    <div class="feature-icon">ðŸ”’</div>
                    <h3>Sicurezza Totale</h3>
                    <p>Crittografia end-to-end, backup automatico e conformitÃ  GDPR.</p>
                </div>
                <div class="feature-card">
                    <div class="feature-icon">âš¡</div>
                    <h3>Funziona Offline</h3>
                    <p>Firma e salva anche senza connessione. Si sincronizza automaticamente quando torni online.</p>
                </div>
                <div class="feature-card">
                    <div class="feature-icon">ðŸ’°</div>
                    <h3>Risparmi fino al 70%</h3>
                    <p>Niente piÃ¹ carta, stampa, spedizioni e archivi fisici. ROI in meno di 3 mesi.</p>
                </div>
            </div>
        </div>
    </section>

    <section class="benefits">
        <div class="container">
            <div class="benefit">
                <div class="benefit-text">
                    <h3><span>Zero carta</span> dal primo giorno</h3>
                    <p>Addio stampe, scanner e archivi polverosi. Tutto digitale, tutto tracciabile, tutto sempre disponibile.</p>
                </div>
                <div class="benefit-img">
                    <img src="SUPPLY.png" alt="Zero carta">
                </div>
            </div>

            <div class="benefit">
                <div class="benefit-text">
                    <h3>Pagamenti piÃ¹ <span>veloci del 40%</span></h3>
                    <p>Il cliente riceve la fattura elettronica nello stesso momento della consegna. Incassi piÃ¹ rapidi garantiti.</p>
                </div>
                <div class="benefit-img">
                    <img src="SUPPLY.png" alt="Pagamenti rapidi">
                </div>
            </div>
        </div>
    </section>

    <section class="cta-final" id="download">
        <div class="container">
            <h2>Pronti a rivoluzionare<br>la vostra logistica?</h2>
            <p style="font-size:1.4rem; margin-bottom:40px;">Prova gratuita di 30 giorni Â· Nessuna carta di credito richiesta</p>
            <a href="#" class="cta-hero">Scarica Supply Chainer Ora</a>
        </div>
    </section>

    <footer>
        <div class="container">
            <div class="logo">
                <img src="SUPPLY.png" alt="Supply Chainer" class="logo-img">
                Supply<span>Chainer</span>
            </div>
            <p>Â© 2025 Supply Chainer srl - Tutti i diritti riservati</p>
        </div>
    </footer>

    <div id="video-modal" class="video-modal">
        <div class="video-modal-content">
            <span class="close-modal">&times;</span>
            <video id="modal-video" width="100%" controls>
                <source src="video/Supplychainer.mp4" type="video/mp4">
                Your browser does not support the video tag.
            </video>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const videoModal = document.getElementById('video-modal');
            const openModalBtn = document.querySelector('a[href="#demo"]');
            const closeModalBtn = document.querySelector('.close-modal');
            const modalVideo = document.getElementById('modal-video');

            openModalBtn.addEventListener('click', (e) => {
                e.preventDefault();
                videoModal.style.display = 'block';
                modalVideo.play();
            });

            closeModalBtn.addEventListener('click', () => {
                videoModal.style.display = 'none';
                modalVideo.pause();
            });

            window.addEventListener('click', (e) => {
                if (e.target == videoModal) {
                    videoModal.style.display = 'none';
                    modalVideo.pause();
                }
            });
        });
    </script>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.skypack.dev/three@0.125.0",
            "gsap": "https://cdn.skypack.dev/gsap@3.5.1",
            "gsap/ScrollTrigger": "https://cdn.skypack.dev/gsap@3.5.1/ScrollTrigger",
            "gsap/MotionPathPlugin": "https://cdn.skypack.dev/gsap@3.5.1/MotionPathPlugin"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import gsap from 'gsap';
        import { ScrollTrigger } from 'gsap/ScrollTrigger';
        import { MotionPathPlugin } from 'gsap/MotionPathPlugin';
        gsap.registerPlugin(ScrollTrigger, MotionPathPlugin);
        const isMobile = window.matchMedia('(max-width: 768px)').matches
        const isCoarse = window.matchMedia('(pointer: coarse)').matches
        const prefersReduceMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches
        const shouldAnimate = !prefersReduceMotion

        const BackgroundGradient = (colorA, colorB) => {
            var mesh = new THREE.Mesh(
                new THREE.PlaneBufferGeometry(2,2,1,1),
                new THREE.ShaderMaterial({
                  uniforms: {
                    uColorA: { value: new THREE.Color(colorA) },
                    uColorB: { value: new THREE.Color(colorB) }
                  },
                  vertexShader: `
                    varying vec2 vUv;
                    void main(){
                        vUv = uv;
                        float depth = -1.;
                        gl_Position = vec4(position.xy, depth, 1.);
                    }
                  `,
                  fragmentShader: 
                  `
                    varying vec2 vUv;
                    uniform vec3 uColorA;
                    uniform vec3 uColorB;
                    void main(){
                        gl_FragColor = vec4(
                            mix( uColorA, uColorB, vec3(vUv.y)),
                            1.
                        );
                    }
                  `
                })
            )
            mesh.material.depthWrite = false
            mesh.renderOrder = -99999
            return mesh
        }

        class Stage {
            constructor(domCanvasElement, topColor, bottomColor) {
                this.canvas = domCanvasElement
                this.scene = new THREE.Scene()
                this.sizes = { width: 0, height: 0 }
                this.background = BackgroundGradient(bottomColor, topColor)
                this.scene.add(this.background)
                this.camera = new THREE.PerspectiveCamera(30, 1, 0.1, 100)
                this.camera.position.set(0, 0, 6)
                this.scene.add(this.camera)
                this.cameraGroup = new THREE.Group();
                this.scene.add(this.cameraGroup);
                const renderer = new THREE.WebGLRenderer({ canvas: this.canvas, antialias: window.devicePixelRatio === 1 ? true : false })
                renderer.physicallyCorrectLights = true
                renderer.outputEncoding = THREE.sRGBEncoding
                renderer.toneMapping = THREE.ACESFilmicToneMapping
                renderer.toneMappingExposure = 1
                this.renderer = renderer
                window.addEventListener('resize', () => { this.onResize() })
                this.onResize()
            }
            onResize() {
                const parent = this.canvas.parentElement
                this.sizes.width = parent.clientWidth
                this.sizes.height = parent.clientHeight
                this.camera.position.z = this.sizes.width < 800 ? 10 : 6
                this.camera.aspect = this.sizes.width / this.sizes.height
                this.camera.updateProjectionMatrix()
                this.renderer.setSize(this.sizes.width, this.sizes.height)
                this.renderer.setPixelRatio(1)
            }
            add(item) { this.scene.add(item) }
            cameraAdd(item) { this.cameraGroup.add(item) }
            render(elapsedTime) {
                this.cameraGroup.position.copy(this.camera.position)
                this.cameraGroup.rotation.copy(this.camera.rotation)
                this.renderer.render(this.scene, this.camera)
            }
        }

        class Loader {
            constructor (color = 'black', shadow = "white", size = 1) {
                this.mesh = new THREE.Mesh(
                    new THREE.PlaneBufferGeometry(2,2,1,1),
                    new THREE.ShaderMaterial({
                    uniforms: {
                        uColor: { value: new THREE.Color(color) },
                        uColorShadow: { value: new THREE.Color(shadow) },
                        uProgress: { value: 0 },
                        uAlpha: { value: 1 },
                        uNoiseSize: { value: size }
                    },
                    vertexShader: `
                        void main(){
                            gl_Position = vec4(position.xy, 0.5, 1.);
                        }
                        `,
                    fragmentShader: `
                        uniform vec3 uColor;
                        uniform float uAlpha;
                        void main () { gl_FragColor = vec4(uColor, uAlpha); }
                    `,
                    transparent: true,
                    depthTest: false
                    })
                )    
            }
            get progress() { return this.mesh.material.uniforms.uProgress.value }
            set progress(v) { this.mesh.material.uniforms.uProgress.value = v }
            get alpha() { return this.mesh.material.uniforms.uAlpha.value }
            set alpha(v) { this.mesh.material.uniforms.uAlpha.value = v }
        }

        const ripVertexShader = `
          uniform float uTearAmount;
          uniform float uTearWidth;
          uniform float uTearXAngle;
          uniform float uTearYAngle;
          uniform float uTearZAngle;
          uniform float uTearXOffset;
          uniform float uXDirection;
          uniform float uRipSide;
          uniform float uRipSeed;
          varying vec2 vUv;
          varying float vAmount;
          mat4 rotationX( in float angle ) {
            return mat4(  1.0,    0,      0,      0,
                    0,  cos(angle), -sin(angle),    0,
                    0,  sin(angle),  cos(angle),    0,
                    0,      0,        0,    1);
          }
          mat4 rotationY( in float angle ) {
            return mat4(  cos(angle),   0,    sin(angle), 0,
                        0,    1.0,       0, 0,
                    -sin(angle),  0,    cos(angle), 0,
                        0,    0,        0,  1);
          }
          mat4 rotationZ( in float angle ) {
            return mat4(  cos(angle),   -sin(angle),  0,  0,
                    sin(angle),   cos(angle),   0,  0,
                        0,        0,    1,  0,
                        0,        0,    0,  1);
          }
          void main(){
            float yAmount = max(0.0, (uTearAmount - (1.0 - uv.y)));
            float zRotate = uTearZAngle * yAmount;
            float xRotate = uTearXAngle * yAmount;
            float yRotate = uTearYAngle * yAmount;
            vec3 rotation = vec3(xRotate* yAmount, yRotate* yAmount, zRotate* yAmount);
            float halfHeight = float(HEIGHT) * 0.5;
            float halfWidth = (float(WIDTH) - uTearWidth * 0.5) * 0.5;
            vec4 vertex = vec4(position.x + (halfWidth * uXDirection) - halfWidth, position.y + halfHeight, position.z, 1.0);
            vertex = vertex * rotationY(rotation.y ) * rotationX(rotation.x  ) * rotationZ(rotation.z  );
            vertex.x += uTearXOffset * yAmount + halfWidth ;
            vertex.y -= halfHeight;
            vec4 modelPosition = modelMatrix * vertex;
            vec4 viewPosition = viewMatrix * modelPosition;
            vec4 projectedPosition = projectionMatrix * viewPosition;
            gl_Position = projectedPosition;
            vUv = uv; vAmount = yAmount;
          }
        `

        const ripFragmentShader = `
          uniform sampler2D uMap; uniform sampler2D uRip; uniform sampler2D uBorder;
          uniform vec3 uShadeColor; uniform float uUvOffset; uniform float uRipSide;
          uniform float uTearXAngle; uniform float uShadeAmount; uniform float uTearWidth;
          uniform float uWhiteThreshold; uniform float uTearOffset; varying vec2 vUv; varying float vAmount;
          void main () {
            bool rightSide = uRipSide == 1.0; float width = float(WIDTH); float widthOverlap = (uTearWidth * 0.5) + width;
            float xScale = widthOverlap / float(FULL_WIDTH); vec2 uvOffset = vec2(vUv.x * xScale + uUvOffset, vUv.y);
            vec4 textureColor = texture2D(uMap, uvOffset); vec4 borderColor = texture2D(uBorder, uvOffset); if(borderColor.r > 0.0) textureColor = vec4(vec3(0.95), 1.0);
            float ripRange = uTearWidth / widthOverlap; float ripStart = rightSide ? 0.0 : 1.0 - ripRange;
            float alpha = 1.0; float ripX = (vUv.x - ripStart) / ripRange; float ripY = vUv.y * 0.5 + (0.5 * uTearOffset);
            vec4 ripCut = texture2D(uRip, vec2(ripX, ripY)); vec4 ripColor = texture2D(uRip, vec2(ripX * 0.9, ripY - 0.02));
            float whiteness = dot(vec4(1.0), ripCut) / 4.0;
            if (!rightSide && whiteness <= uWhiteThreshold) { whiteness = dot(vec4(1.0), ripColor) / 4.0; if(whiteness >= uWhiteThreshold) textureColor = ripColor; else alpha = 0.0; }
            if (rightSide && whiteness >= uWhiteThreshold) alpha = 0.0;
            gl_FragColor = mix(vec4(textureColor.rgb, alpha), vec4(uShadeColor, alpha), vAmount * uShadeAmount);
          }
        `

        class Photo {
            constructor(textures, destoryCallback) {
                this.destroyCallback = destoryCallback
                this.photoTexture = textures.photo; this.borderTexture = textures.border; this.ripTexture = textures.rip; this.interactive = false;
                this.group = new THREE.Group(); this.group.rotation.z = (Math.random() * 2 - 1) * Math.PI; this.group.position.y = 10
                setTimeout(() => { this.interactive = true }, 400)
                const introAnimation = gsap.timeline({ delay: 0.3, defaults: { duration: 0.8, ease: 'power3.out' } })
                introAnimation.to(this.group.rotation, {z: 0}, 0)
                introAnimation.to(this.group.position, {y: 0}, 0)
                const width = 3; const tearWidth = 0.4;
                this.sheetSettings = {
                    widthSegments: 30, heightSegments: 50, tearOffset: Math.random(), width: width, height: 2, tearAmount: 0, tearWidth: tearWidth, ripWhiteThreshold: 0.7,
                    left: { uvOffset: 0, ripSide: 0, tearXAngle: -0.01, tearYAngle: -0.1, tearZAngle: 0.05, tearXOffset: 0, direction: -1, shadeColor: new THREE.Color('white'), shadeAmount: 0.2 },
                    right:{ uvOffset: ((width - tearWidth) / width) * 0.5, ripSide: 1, tearXAngle: 0.2, tearYAngle: 0.1, tearZAngle: -0.1, tearXOffset: 0, direction: 1, shadeColor: new THREE.Color('black'), shadeAmount: 0.4 }
                }
                this.sides = [ { id: 'left', mesh: null, material: null }, { id: 'right', mesh: null, material: null } ]
                this.sheetPlane = new THREE.PlaneBufferGeometry(this.sheetSettings.width / 2 + this.sheetSettings.tearWidth / 2, this.sheetSettings.height, this.sheetSettings.widthSegments, this.sheetSettings.heightSegments);
                this.sides.forEach(side => {
                    side.material = this.getRipMaterial(side.id)
                    side.mesh = new THREE.Mesh( this.sheetPlane, side.material)
                    if(this.sheetSettings[side.id].tearXAngle > 0) { side.mesh.position.z += 0.0001 }
                    this.group.add(side.mesh);
                })
            }
            getRipMaterial(side) {
                const material =  new THREE.ShaderMaterial({ 
                    defines: { HEIGHT: this.sheetSettings.height, WIDTH: this.sheetSettings.width / 2, FULL_WIDTH: this.sheetSettings.width, HEIGHT_SEGMENTS: this.sheetSettings.heightSegments, WIDTH_SEGMENTS: this.sheetSettings.widthSegments },
                    uniforms: {
                       uMap : { value: this.photoTexture }, uRip : { value: this.ripTexture }, uBorder : { value: this.borderTexture },
                       uRipSide : { value: this.sheetSettings[side].ripSide }, uTearWidth : { value: this.sheetSettings.tearWidth }, uWhiteThreshold: { value: this.sheetSettings.ripWhiteThreshold },
                       uTearAmount: { value: this.sheetSettings.tearAmount }, uTearOffset: { value: this.sheetSettings.tearOffset }, uUvOffset: { value: this.sheetSettings[side].uvOffset },
                       uTearXAngle: { value: this.sheetSettings[side].tearXAngle }, uTearYAngle: { value: this.sheetSettings[side].tearYAngle }, uTearZAngle: { value: this.sheetSettings[side].tearZAngle },
                       uTearXOffset: { value: this.sheetSettings[side].tearXOffset }, uXDirection: { value: this.sheetSettings[side].direction }, uShadeColor: { value: this.sheetSettings[side].shadeColor }, uShadeAmount: { value: this.sheetSettings[side].shadeAmount },
                   },
                   transparent: true, vertexShader: ripVertexShader, fragmentShader: ripFragmentShader
                })
                return material;
            }
            shouldCompleteRip() { return this.sheetSettings.tearAmount >= 1.5 }
            updateUniforms() {
                if(this.interactive && this.shouldCompleteRip()) { this.remove(); } else {
                    if(this.sheetSettings.tearAmount === 0) this.sheetSettings.tearOffset = Math.random();
                    this.sides.forEach(side => {
                        const uniforms = side.mesh.material.uniforms
                        uniforms.uTearAmount.value = this.sheetSettings.tearAmount
                        uniforms.uTearOffset.value = this.sheetSettings.tearOffset
                        uniforms.uUvOffset.value = this.sheetSettings[side.id].uvOffset
                        uniforms.uTearXAngle.value = this.sheetSettings[side.id].tearXAngle
                        uniforms.uTearYAngle.value = this.sheetSettings[side.id].tearYAngle
                        uniforms.uTearZAngle.value = this.sheetSettings[side.id].tearZAngle
                        uniforms.uTearXOffset.value = this.sheetSettings[side.id].tearXOffset
                        uniforms.uXDirection.value = this.sheetSettings[side.id].direction
                        uniforms.uShadeColor.value = this.sheetSettings[side.id].shadeColor
                        uniforms.uShadeAmount.value = this.sheetSettings[side.id].shadeAmount
                        uniforms.uWhiteThreshold.value = this.sheetSettings.ripWhiteThreshold
                    })
                }
            }
            completeRip() { if(this.sheetSettings.tearAmount >= 1.15) this.remove(); else this.reset() }
            reset() { gsap.to(this.sheetSettings, {tearAmount: 0, onUpdate: () => this.updateUniforms()}) }
            remove() {
                this.interactive = false
                this.destroyCallback()
                const tl = gsap.timeline({ defaults: {duration: 1, ease: 'power2.in'}, onComplete: () => this.destroyMe() })
                tl.to(this.sheetSettings, {tearAmount: 1.5 + Math.random() * 1.5, ease: 'power2.out', onUpdate: () => this.updateUniforms()})
                tl.to(this.group.position, {z: 1}, 0)
                this.sides.forEach(side => {
                    tl.to(side.mesh.position, {y: -3 + (Math.random() * -3), x: (2 + (Math.random() * 3)) * (this.sheetSettings[side.id].ripSide - 0.5) }, 0)
                    tl.to(side.mesh.rotation, {z: (-2 + Math.random() * -3) * (this.sheetSettings[side.id].ripSide - 0.5) }, 0)
                })
            }
            destroyMe() {
                this.sheetPlane.dispose()
                this.sides.forEach(side => { side.material.dispose(); this.group.remove(side.mesh) })
            }
        }

        let interacted = false;
        let overlayText, overlayAccent;
        const canvas = document.querySelector('.hero-anim .webgl')
        const stage = new Stage(canvas, '#F1EBE4', '#D5C3AE')
        const loaderScreen = new Loader('black'); stage.add(loaderScreen.mesh);
        const loadingManager = new THREE.LoadingManager(() => { const tl = gsap.timeline(); tl.to(loaderScreen, {progress: 1, alpha: 0, duration: .5, ease: 'power4.inOut'}, 0); init(); })
        const textureLoader = new THREE.TextureLoader(loadingManager)
        let envLight = new THREE.AmbientLight({color: 'white', intensity: 6}); stage.add(envLight)
        let pointLight = new THREE.PointLight({color: 'white', intensity: 20}); pointLight.position.z = -1; stage.add(pointLight)
        const images = [
            { texture: textureLoader.load('SUPPLY.png'), colors: [[213,195,174], [241,235,228]] },
            { texture: textureLoader.load('SUPPLY.png'), colors: [[213,195,174], [241,235,228]] }
        ]
        let currentImage = -1;
        const textureRip = textureLoader.load('https://assets.codepen.io/557388/rip.jpg')
        const textureBorder = textureLoader.load('https://assets.codepen.io/557388/border.png')
        const photos = []; const mouseStart = new THREE.Vector2(); let mouseDown = false;
        const extraImages = [
            { file: 'SUPPLY.png', colors: [[213,195,174], [241,235,228]] },
            { file: 'SUPPLY.png', colors: [[213,195,174], [241,235,228]] },
            { file: 'SUPPLY.png', colors: [[213,195,174], [241,235,228]] }
        ]
        const postInitTextureLoader = new THREE.TextureLoader()
        const getMousePos = (x, y) => {
            const rect = canvas.getBoundingClientRect()
            return { x: ((x - rect.left) / rect.width) * 2 - 1, y: - ((y - rect.top) / rect.height) * 2 + 1 }
        }
        const toCss = (arr) => `rgb(${arr[0]}, ${arr[1]}, ${arr[2]})`
        const mix = (a, b, t) => [
            Math.round(a[0] * (1 - t) + b[0] * t),
            Math.round(a[1] * (1 - t) + b[1] * t),
            Math.round(a[2] * (1 - t) + b[2] * t)
        ]
        const parallax = (clientX, clientY) => {
            if(!overlayText) return;
            const rect = canvas.parentElement.getBoundingClientRect()
            const nx = ((clientX - rect.left) / rect.width) - 0.5
            const ny = ((clientY - rect.top) / rect.height) - 0.5
            gsap.to(overlayText, { x: nx * 20, y: ny * 16, duration: 0.25, ease: 'power2.out' })
        }
        const down = (x, y) => {
            if(photos.length && photos[0].interactive) { interacted = true; let pos = getMousePos(x, y); mouseStart.x = pos.x; mouseStart.y = pos.y; mouseDown = true; }
        }
        const move = (x, y) => {
            if(mouseDown && photos.length && photos[0].interactive) { let pos = getMousePos(x, y); let distanceY = mouseStart.y - pos.y; photos[0].sheetSettings.tearAmount = Math.max(2 * distanceY, 0); photos[0].updateUniforms(); }
        }
        const up = () => { if(mouseDown && photos.length && photos[0].interactive) { mouseDown = false; photos[0].completeRip(); } }
        const loadExtraPhoto = () => { const nextImage = extraImages.shift(); images.push({ texture: postInitTextureLoader.load(nextImage.file), colors: nextImage.colors }) }
        const addNewPhoto = () => {
            currentImage++; if(currentImage >= images.length) currentImage = 0
            if(images.length - currentImage < 2 && extraImages.length) loadExtraPhoto()
            mouseDown = false; const nextImage = images[currentImage]
            let photo = new Photo({ photo: nextImage.texture, rip: textureRip, border: textureBorder }, () => addNewPhoto());
            photos.unshift(photo); stage.add(photo.group);
            gsap.to(stage.background.material.uniforms.uColorB.value, { r: nextImage.colors[0][0] / 255, g: nextImage.colors[0][1] / 255, b: nextImage.colors[0][2] / 255, ease:'power4.inOut', duration: 1 })
            gsap.to(stage.background.material.uniforms.uColorA.value, { r: nextImage.colors[1][0] / 255, g: nextImage.colors[1][1] / 255, b: nextImage.colors[1][2] / 255, ease:'power4.inOut', duration: 1 })
            if(overlayText){
                const base = mix(nextImage.colors[1], [255,255,255], 0.65)
                const accent = mix(nextImage.colors[0], [255,180,0], 0.4)
                gsap.to(overlayText, { color: toCss(base), duration: 0.8, ease: 'power2.out' })
                if(overlayAccent) gsap.to(overlayAccent, { color: toCss(accent), duration: 0.8, ease: 'power2.out' })
            }
        }
        const init = () => {
            addNewPhoto();
            canvas.addEventListener('mousedown', (event) => down(event.clientX, event.clientY))
            canvas.addEventListener('touchstart', (event) => down(event.touches[0].clientX, event.touches[0].clientY), {passive: true})
            window.addEventListener('mousemove', (event) => move(event.clientX, event.clientY))
            window.addEventListener('touchmove', (event) => move(event.touches[0].clientX, event.touches[0].clientY), {passive: true})
            window.addEventListener('mouseup', up)
            window.addEventListener('touchend', up)
            overlayText = document.querySelector('.hero-anim-text')
            overlayAccent = overlayText.querySelector('span')
            gsap.fromTo(overlayText, {opacity: 0, y: -20}, {opacity: 1, y: 0, duration: 1, ease: 'power3.out'})
            const container = canvas.parentElement
            container.addEventListener('mousemove', (e) => parallax(e.clientX, e.clientY))
            container.addEventListener('touchmove', (e) => parallax(e.touches[0].clientX, e.touches[0].clientY), {passive: true})
        }
        const clock = new THREE.Clock()
        let running = true
        const observer = new IntersectionObserver((entries) => {
            running = entries[0].isIntersecting
        }, { threshold: 0.1 })
        observer.observe(canvas.parentElement)
        const tick = () => { const elapsedTime = clock.getElapsedTime(); if(running) stage.render(elapsedTime); window.requestAnimationFrame(tick) }
        tick()

        if(shouldAnimate && !isMobile){
            gsap.to('.logo .logo-img', { duration: 1.2, ease: 'power2.inOut', motionPath: { path: [{x:0,y:0},{x:18,y:-10},{x:0,y:0}] }, repeat: 1, yoyo: true })
        }
        if(shouldAnimate){
            const sections = Array.from(document.querySelectorAll('section'))
            const offset = isMobile ? 30 : 60
            sections.forEach((sec, i) => {
                const content = sec.querySelector('.container') || sec
                const dir = (i % 2 === 0) ? -offset : offset
                gsap.from(content, { opacity: 0, x: dir, duration: 0.8, ease: 'power3.out', scrollTrigger: { trigger: sec, start: 'top 85%', once: true } })
            })
        }
        if(shouldAnimate){
            document.querySelectorAll('.feature-card').forEach((card, i) => {
                const dir = (i % 2 === 0) ? (isMobile ? -24 : -40) : (isMobile ? 24 : 40)
                gsap.from(card, { opacity: 0, x: dir, duration: 0.6, ease: 'power3.out', scrollTrigger: { trigger: card, start: 'top 85%', once: true } })
            })
        }
        document.querySelectorAll('.benefit').forEach((b, i) => { 
            const img = b.querySelector('.benefit-img img'); 
            if(img) gsap.to(img, { yPercent: isMobile ? -5 : -10, scrollTrigger: { trigger: b, start: 'top bottom', end: 'bottom top', scrub: true } })
            if(shouldAnimate){
                const dir = (i % 2 === 0) ? (isMobile ? -28 : -50) : (isMobile ? 28 : 50)
                gsap.from(b, { opacity: 0, x: dir, duration: 0.7, ease: 'power3.out', scrollTrigger: { trigger: b, start: 'top 85%', once: true } })
            }
        })
        gsap.from('.cta-final .cta-hero', { scale: 0.92, opacity: 0, duration: 0.6, ease: 'back.out(1.7)', scrollTrigger: { trigger: '.cta-final', start: 'top 80%' } })
        gsap.to('header', { paddingTop: isMobile ? 10 : 12, paddingBottom: isMobile ? 10 : 12, duration: 0.2, scrollTrigger: { trigger: 'body', start: 'top top', end: '+=200', scrub: true } })

        gsap.to('.progress-bar__inner', { scaleX: 1, ease: 'none', scrollTrigger: { trigger: document.body, start: 'top top', end: 'bottom bottom', scrub: true } })
        gsap.to('.hero-anim-text', { y: isMobile ? '+=3' : '+=6', duration: 2, ease: 'sine.inOut', yoyo: true, repeat: -1 })

        document.querySelectorAll('a[href^="#"]').forEach(a => {
            a.addEventListener('click', (e) => {
                const id = a.getAttribute('href').slice(1)
                const target = document.getElementById(id)
                if(target){
                    e.preventDefault()
                    const y = target.getBoundingClientRect().top + window.pageYOffset - 80
                    window.scrollTo({ top: y, behavior: 'smooth' })
                }
            })
        })

        const magneticCard = (el) => {
            const rect = () => el.getBoundingClientRect()
            const reset = () => gsap.to(el, { x: 0, y: 0, duration: 0.25, ease: 'power3.out' })
            el.addEventListener('mousemove', (e) => {
                const r = rect();
                const nx = ((e.clientX - r.left) / r.width - 0.5) * 14
                const ny = ((e.clientY - r.top) / r.height - 0.5) * 12
                gsap.to(el, { x: nx, y: ny, duration: 0.25, ease: 'power3.out', overwrite: 'auto' })
            })
            el.addEventListener('mouseleave', reset)
            el.addEventListener('touchend', reset)
        }
        if(!isCoarse){ document.querySelectorAll('.feature-card').forEach(magneticCard) }

        const magnetic = (el) => {
            const rect = () => el.getBoundingClientRect()
            const reset = () => gsap.to(el, { x: 0, y: 0, duration: 0.25, ease: 'power3.out' })
            el.addEventListener('mousemove', (e) => {
                const r = rect(); const nx = ((e.clientX - r.left) / r.width - 0.5) * 24; const ny = ((e.clientY - r.top) / r.height - 0.5) * 18;
                gsap.to(el, { x: nx, y: ny, duration: 0.25, ease: 'power3.out', overwrite: 'auto' })
            })
            el.addEventListener('mouseleave', reset)
            el.addEventListener('touchend', reset)
        }
        if(!isCoarse){ document.querySelectorAll('.cta-hero, .cta-header').forEach(magnetic) }

        const counterEl = Array.from(document.querySelectorAll('.feature-card h3')).find(h => /Risparmi\s+fino\s+al\s+\d+%/i.test(h.textContent))
        if(counterEl){
            const match = counterEl.textContent.match(/(\d+)%/); const target = match ? parseInt(match[1], 10) : 70
            const state = { v: 0 }
            ScrollTrigger.create({
                trigger: counterEl, start: 'top 85%', once: true,
                onEnter: () => gsap.to(state, { v: target, duration: 1.2, ease: 'power3.out', onUpdate: () => { const n = Math.round(state.v); counterEl.textContent = counterEl.textContent.replace(/\d+%/, n + '%') } })
            })
        }

        const splitTitle = document.querySelector('.section-title')
        if(splitTitle){
            ScrollTrigger.create({ trigger: splitTitle, start: 'top 85%', once: true, onEnter: () => gsap.to('.section-title span.word', { opacity: 1, y: 0, duration: 0.6, stagger: 0.06, ease: 'power3.out' }) })
        }
    </script>

</body>
</html>